import { 
  ZoteroItem, 
  ZoteroAPIItem, 
  AppReference, 
  ZoteroConfig, 
  ZoteroError,
  ZoteroItemType,
  ZoteroCreatorType 
} from './types';

export class ZoteroClient {
  private apiKey: string;
  private userId: string;
  private baseUrl: string = 'https://api.zotero.org';
  private libraryType: 'user' | 'group' = 'user';
  private timeout: number = 30000;
  private retryAttempts: number = 3;

  constructor(apiKey: string, userId: string, config?: Partial<ZoteroConfig>) {
    if (!apiKey || apiKey.trim() === '') {
      throw new Error('Zotero API key is required');
    }
    if (!userId || userId.trim() === '') {
      throw new Error('Zotero user ID is required');
    }

    this.apiKey = apiKey;
    this.userId = userId;
    
    if (config) {
      this.libraryType = config.libraryType || this.libraryType;
      this.timeout = config.timeout || this.timeout;
      this.retryAttempts = config.retryAttempts || this.retryAttempts;
    }
  }

  isConfigured(): boolean {
    return !!(this.apiKey && this.userId);
  }

  async getItems(limit: number = 100, start: number = 0): Promise<ZoteroItem[]> {
    const url = `${this.baseUrl}/${this.libraryType}s/${this.userId}/items?limit=${limit}&start=${start}&format=json`;
    
    const response = await this.makeRequest(url, {
      method: 'GET',
      headers: this.getHeaders()
    });

    const items: ZoteroAPIItem[] = await response.json();
    return items.map(item => this.convertZoteroToApp(item));
  }

  async createItem(reference: Partial<AppReference>): Promise<{ key: string }> {
    const zoteroFormat = this.convertFromAppFormat(reference);
    const url = `${this.baseUrl}/${this.libraryType}s/${this.userId}/items`;
    
    const response = await this.makeRequest(url, {
      method: 'POST',
      headers: {
        ...this.getHeaders(),
        'Content-Type': 'application/json'
      },
      body: JSON.stringify([zoteroFormat])
    });

    const result = await response.json();
    return { key: result[0].key };
  }

  async updateItem(itemKey: string, reference: Partial<AppReference>): Promise<void> {
    const zoteroFormat = this.convertFromAppFormat(reference);
    const url = `${this.baseUrl}/${this.libraryType}s/${this.userId}/items/${itemKey}`;
    
    await this.makeRequest(url, {
      method: 'PUT',
      headers: {
        ...this.getHeaders(),
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(zoteroFormat)
    });
  }

  async deleteItem(itemKey: string): Promise<void> {
    const url = `${this.baseUrl}/${this.libraryType}s/${this.userId}/items/${itemKey}`;
    
    await this.makeRequest(url, {
      method: 'DELETE',
      headers: this.getHeaders()
    });
  }

  exportToBibTeX(items: ZoteroItem[]): string {
    return items.map(item => this.itemToBibTeX(item)).join('\n\n');
  }

  convertToAppFormat(zoteroItem: ZoteroItem): AppReference {
    const citation = this.generateCitation(zoteroItem.authors, zoteroItem.year);
    
    return {
      id: zoteroItem.key,
      title: zoteroItem.title,
      authors: zoteroItem.authors,
      year: zoteroItem.year,
      source: 'Zotero',
      citation,
      doi: zoteroItem.doi,
      abstract: zoteroItem.abstract,
      url: zoteroItem.url
    };
  }

  convertFromAppFormat(appReference: Partial<AppReference>): Record<string, unknown> {
    const creators = (appReference.authors || []).map(author => {
      const parts = author.trim().split(' ');
      const lastName = parts.pop() || '';
      const firstName = parts.join(' ');
      
      return {
        firstName,
        lastName,
        creatorType: ZoteroCreatorType.AUTHOR
      };
    });

    return {
      itemType: ZoteroItemType.JOURNAL_ARTICLE,
      title: appReference.title || '',
      creators,
      date: appReference.year?.toString() || '',
      publicationTitle: appReference.source || '',
      DOI: appReference.doi || '',
      url: appReference.url || '',
      abstractNote: appReference.abstract || '',
      extra: 'Generated by Academic Workflow application'
    };
  }

  private async makeRequest(url: string, options: RequestInit, attempt: number = 1): Promise<Response> {
    try {
      const response = await fetch(url, {
        ...options,
        signal: AbortSignal.timeout(this.timeout)
      });

      if (!response.ok) {
        if (response.status === 429 && attempt <= this.retryAttempts) {
          // Rate limiting - wait and retry
          const retryAfter = parseInt(response.headers.get('Retry-After') || '5');
          await this.sleep(retryAfter * 1000);
          return this.makeRequest(url, options, attempt + 1);
        }

        const errorText = await response.text();
        const error = new Error(`Zotero API Error (${response.status}): ${errorText}`) as ZoteroError;
        error.status = response.status;
        error.response = errorText;
        error.retryable = response.status >= 500 || response.status === 429;
        throw error;
      }

      return response;
    } catch (error: unknown) {
      if ((error as { name?: string }).name === 'AbortError') {
        throw new Error('Zotero API request timed out');
      }
      if (attempt <= this.retryAttempts && this.isRetryableError(error)) {
        await this.sleep(1000 * attempt); // Exponential backoff
        return this.makeRequest(url, options, attempt + 1);
      }
      throw error;
    }
  }

  private getHeaders(): Record<string, string> {
    return {
      'Zotero-API-Key': this.apiKey,
      'User-Agent': 'Academic-Workflow/1.0',
      'Accept': 'application/json'
    };
  }

  private convertZoteroToApp(apiItem: ZoteroAPIItem): ZoteroItem {
    const data = apiItem.data;
    
    // Convert creators to simple author strings
    const authors = (data.creators || []).map(creator => {
      if (creator.name) {
        return creator.name;
      }
      return `${creator.firstName || ''} ${creator.lastName}`.trim();
    });

    // Parse year from date
    const year = parseInt(data.date) || new Date().getFullYear();

    return {
      key: apiItem.key,
      title: data.title || '',
      authors,
      year,
      source: data.publicationTitle || data.journalAbbreviation || 'Unknown',
      doi: data.DOI,
      abstract: data.abstractNote,
      itemType: data.itemType,
      url: data.url,
      pages: data.pages,
      volume: data.volume,
      issue: data.issue
    };
  }

  private itemToBibTeX(item: ZoteroItem): string {
    const type = this.getBibTeXType(item.itemType);
    const key = this.generateBibTeXKey(item);
    const authors = item.authors.join(' and ');
    
    let bibtex = `@${type}{${key},\n`;
    bibtex += `  title={${item.title}},\n`;
    bibtex += `  author={${authors}},\n`;
    bibtex += `  year={${item.year}},\n`;
    
    if (item.source && item.source !== 'Unknown') {
      bibtex += `  journal={${item.source}},\n`;
    }
    if (item.volume) {
      bibtex += `  volume={${item.volume}},\n`;
    }
    if (item.issue) {
      bibtex += `  number={${item.issue}},\n`;
    }
    if (item.pages) {
      bibtex += `  pages={${item.pages}},\n`;
    }
    if (item.doi) {
      bibtex += `  doi={${item.doi}},\n`;
    }
    if (item.url) {
      bibtex += `  url={${item.url}},\n`;
    }
    
    bibtex = bibtex.replace(/,\n$/, '\n'); // Remove trailing comma
    bibtex += '}';
    
    return bibtex;
  }

  private getBibTeXType(itemType: string): string {
    const typeMap: Record<string, string> = {
      'journalArticle': 'article',
      'book': 'book',
      'bookSection': 'inbook',
      'conferencePaper': 'inproceedings',
      'thesis': 'phdthesis',
      'report': 'techreport',
      'webpage': 'misc'
    };
    return typeMap[itemType] || 'article';
  }

  private generateBibTeXKey(item: ZoteroItem): string {
    const firstAuthor = item.authors[0] || 'unknown';
    const lastName = firstAuthor.split(' ').pop()?.toLowerCase() || 'unknown';
    return `${lastName}${item.year}`;
  }

  private generateCitation(authors: string[], year: number): string {
    if (authors.length === 0) {
      return `(Unknown, ${year})`;
    }
    
    if (authors.length === 1) {
      const lastName = authors[0].split(' ').pop();
      return `(${lastName}, ${year})`;
    }
    
    if (authors.length === 2) {
      const lastName1 = authors[0].split(' ').pop();
      const lastName2 = authors[1].split(' ').pop();
      return `(${lastName1} & ${lastName2}, ${year})`;
    }
    
    const lastName = authors[0].split(' ').pop();
    return `(${lastName} et al., ${year})`;
  }

  private isRetryableError(error: unknown): boolean {
    if (error && typeof error === 'object' && 'code' in error) {
      const errorCode = (error as { code: string }).code;
      return errorCode === 'ECONNRESET' || 
             errorCode === 'ECONNREFUSED' || 
             errorCode === 'ETIMEDOUT';
    }
    if (error instanceof Error) {
      return error.message.includes('network') ||
             error.message.includes('timeout');
    }
    return false;
  }

  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}